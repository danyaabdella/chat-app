A sample real-time chat application:
- Backend: NestJS, Socket.IO (Redis adapter), Prisma (Postgres)
- Frontend: React (Vite) + socket.io-client
- Containerized: Docker + Docker Compose
- PM2 in cluster mode inside backend container
- Socket.IO Redis adapter ensures real-time across instances

## Architecture
- `postgres` persistent DB (Prisma)
- `redis` pub/sub for socket.io adapter
- `backend` NestJS app (pm2 cluster)
- `frontend` static SPA served by nginx

## Installation & Setup

### 1. Clone the Repository

```bash
git clone <repository-url>
cd chat-app


### 2. Environment Setup

Create environment files:

cd backend/.env



Update the environment variables:

**Backend (.env)**
```env
DATABASE_URL="postgresql://usrname:password@localhost:5432/chatdb?schema=public"
REDIS_HOST=localhost
REDIS_PORT=6379
PORT=3001
FRONTEND_URL=http://localhost:3001
NODE_ENV=development

### 3. Docker Setup (Recommended)

#### Development Environment

```bash
# Start database services
docker-compose -f docker-compose.dev.yml up -d

# Install backend dependencies
cd backend
npm install

# Generate Prisma client
npx prisma generate

# Run database migrations
npx prisma migrate dev

# Start backend in development mode
npm run start:dev

# In a new terminal, install frontend dependencies
cd ../frontend
npm install

# Start frontend
npm start
```

#### Production Environment

```bash
# Build and start all services
docker-compose up -d

# Or with load balancer
docker-compose --profile loadbalancer up -d
```

### 4. Manual Setup (Alternative)

#### Backend Setup

```bash
cd backend

# Install dependencies
npm install

# Generate Prisma client
npx prisma generate

# Setup database
npx prisma migrate dev

# Start development server
npm run start:dev
```

#### Frontend Setup

```bash
cd frontend

# Install dependencies
npm install

# Start development server
npm start
```

## Production Deployment

### 1. Build for Production

```bash
# Backend
cd backend
npm run build

# Frontend
cd ../frontend
npm run build
```

### 2. PM2 Cluster Mode

```bash
cd backend

# Start with PM2 in cluster mode
npm run start:pm2

# Or manually with PM2
pm2 start ecosystem.config.js --env production

# Monitor processes
pm2 monit

# View logs
pm2 logs

# Stop processes
pm2 stop chat-backend

# Restart processes
pm2 restart chat-backend
```

### 3. Docker Production Deployment

```bash
# Build and start with Docker Compose
docker-compose up -d

# Scale backend instances
docker-compose up -d --scale backend=3

# View logs
docker-compose logs -f
```

## API Endpoints

### Users
- `POST /users` - Create a new user
- `GET /users` - Get all users
- `GET /users/:id` - Get user by ID

### Chat
- `GET /chat/rooms/:userId` - Get user's rooms
- `GET /chat/rooms/:roomId/messages` - Get room messages
- `POST /chat/rooms` - Create a new room

### WebSocket Events

#### Client to Server
- `sendMessage` - Send a message
- `joinRoom` - Join a room
- `leaveRoom` - Leave a room
- `typing` - Typing indicator

#### Server to Client
- `newMessage` - New message received
- `userJoined` - User joined room
- `userLeft` - User left room
- `userOnline` - User came online
- `userOffline` - User went offline
- `userTyping` - User typing indicator

## Database Schema

### Users
- `id` - Unique identifier
- `username` - Unique username
- `email` - Email address (optional)
- `createdAt` - Creation timestamp
- `updatedAt` - Last update timestamp

### Rooms
- `id` - Unique identifier
- `name` - Room name
- `type` - Room type (DIRECT/GROUP)
- `createdAt` - Creation timestamp
- `updatedAt` - Last update timestamp

### Messages
- `id` - Unique identifier
- `content` - Message content
- `userId` - Author ID
- `roomId` - Room ID
- `createdAt` - Creation timestamp
- `updatedAt` - Last update timestamp

## Scaling Considerations

### Horizontal Scaling
- PM2 cluster mode automatically utilizes all available CPU cores
- Redis adapter ensures Socket.IO works across multiple instances
- Load balancer distributes HTTP requests

### Performance Optimization
- Database indexing on frequently queried fields
- Redis caching for session management
- Gzip compression for API responses
- Static asset caching with Nginx

### Monitoring
- Health check endpoints
- PM2 monitoring and logging
- Docker health checks
- Application metrics (when deployed)

## Development Commands

### Backend
```bash
cd backend

# Development
npm run start:socket:dev

# Production build
npm run build

# Production start
npm run start:prod

# PM2 cluster mode
npm run start:pm2

# Database commands
npx prisma migrate dev
npx prisma generate
npx prisma studio
npx prisma db seed
```

### Frontend
```bash
cd frontend

# Development
npm start

# Production build
npm run build

# Test
npm test
```

## Troubleshooting

### Common Issues

1. **Database Connection**
   - Ensure PostgreSQL is running
   - Check DATABASE_URL in .env
   - Verify database exists

2. **Redis Connection**
   - Ensure Redis is running
   - Check REDIS_HOST and REDIS_PORT
   - Verify Redis adapter configuration

3. **Socket.IO Connection**
   - Check CORS configuration
   - Verify FRONTEND_URL matches
   - Check network connectivity

4. **PM2 Issues**
   - Check PM2 logs: `pm2 logs`
   - Verify ecosystem.config.js
   - Check port availability
